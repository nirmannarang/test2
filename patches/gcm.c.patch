--- /home/test/gcm.c_old	2019-07-26 11:31:52.219049886 +0000
+++ src/crypto/fipsmodule/modes/gcm.c	2019-07-26 12:58:11.472986326 +0000
@@ -167,8 +167,8 @@
     Z.lo ^= Htable[nlo].lo;
   }
 
-  Xi[0] = CRYPTO_bswap8(Z.hi);
-  Xi[1] = CRYPTO_bswap8(Z.lo);
+  Xi[0] = CRYPTO_BSWAP8(Z.hi);
+  Xi[1] = CRYPTO_BSWAP8(Z.lo);
 }
 
 // Streamed gcm_mult_4bit, see CRYPTO_gcm128_[en|de]crypt for
@@ -227,8 +227,8 @@
       Z.lo ^= Htable[nlo].lo;
     }
 
-    Xi[0] = CRYPTO_bswap8(Z.hi);
-    Xi[1] = CRYPTO_bswap8(Z.lo);
+    Xi[0] = CRYPTO_BSWAP8(Z.hi);
+    Xi[1] = CRYPTO_BSWAP8(Z.lo);
   } while (inp += 16, len -= 16);
 }
 #endif   // !GHASH_ASM || AARCH64 || PPC64LE
@@ -289,8 +289,8 @@
   OPENSSL_memcpy(H.c, gcm_key, 16);
 
   // H is stored in host byte order
-  H.u[0] = CRYPTO_bswap8(H.u[0]);
-  H.u[1] = CRYPTO_bswap8(H.u[1]);
+  H.u[0] = CRYPTO_BSWAP8(H.u[0]);
+  H.u[1] = CRYPTO_BSWAP8(H.u[1]);
 
   OPENSSL_memcpy(out_key, H.c, 16);
 
@@ -415,15 +415,15 @@
       GCM_MUL(ctx, Yi);
     }
     len0 <<= 3;
-    ctx->Yi.u[1] ^= CRYPTO_bswap8(len0);
+    ctx->Yi.u[1] ^= CRYPTO_BSWAP8(len0);
 
     GCM_MUL(ctx, Yi);
-    ctr = CRYPTO_bswap4(ctx->Yi.d[3]);
+    ctr = CRYPTO_BSWAP4(ctx->Yi.d[3]);
   }
 
   (*ctx->gcm_key.block)(ctx->Yi.c, ctx->EK0.c, key);
   ++ctr;
-  ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+  ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
 }
 
 int CRYPTO_gcm128_aad(GCM128_CONTEXT *ctx, const uint8_t *aad, size_t len) {
@@ -519,14 +519,14 @@
     }
   }
 
-  uint32_t ctr = CRYPTO_bswap4(ctx->Yi.d[3]);
+  uint32_t ctr = CRYPTO_BSWAP4(ctx->Yi.d[3]);
   while (len >= GHASH_CHUNK) {
     size_t j = GHASH_CHUNK;
 
     while (j) {
       (*block)(ctx->Yi.c, ctx->EKi.c, key);
       ++ctr;
-      ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+      ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
       for (size_t i = 0; i < 16; i += sizeof(size_t)) {
         store_word_le(out + i,
                       load_word_le(in + i) ^ ctx->EKi.t[i / sizeof(size_t)]);
@@ -543,7 +543,7 @@
     while (len >= 16) {
       (*block)(ctx->Yi.c, ctx->EKi.c, key);
       ++ctr;
-      ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+      ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
       for (size_t i = 0; i < 16; i += sizeof(size_t)) {
         store_word_le(out + i,
                       load_word_le(in + i) ^ ctx->EKi.t[i / sizeof(size_t)]);
@@ -557,7 +557,7 @@
   if (len) {
     (*block)(ctx->Yi.c, ctx->EKi.c, key);
     ++ctr;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     while (len--) {
       ctx->Xi.c[n] ^= out[n] = in[n] ^ ctx->EKi.c[n];
       ++n;
@@ -609,7 +609,7 @@
     }
   }
 
-  uint32_t ctr = CRYPTO_bswap4(ctx->Yi.d[3]);
+  uint32_t ctr = CRYPTO_BSWAP4(ctx->Yi.d[3]);
   while (len >= GHASH_CHUNK) {
     size_t j = GHASH_CHUNK;
 
@@ -617,7 +617,7 @@
     while (j) {
       (*block)(ctx->Yi.c, ctx->EKi.c, key);
       ++ctr;
-      ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+      ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
       for (size_t i = 0; i < 16; i += sizeof(size_t)) {
         store_word_le(out + i,
                       load_word_le(in + i) ^ ctx->EKi.t[i / sizeof(size_t)]);
@@ -634,7 +634,7 @@
     while (len >= 16) {
       (*block)(ctx->Yi.c, ctx->EKi.c, key);
       ++ctr;
-      ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+      ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
       for (size_t i = 0; i < 16; i += sizeof(size_t)) {
         store_word_le(out + i,
                       load_word_le(in + i) ^ ctx->EKi.t[i / sizeof(size_t)]);
@@ -647,7 +647,7 @@
   if (len) {
     (*block)(ctx->Yi.c, ctx->EKi.c, key);
     ++ctr;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     while (len--) {
       uint8_t c = in[n];
       ctx->Xi.c[n] ^= c;
@@ -709,11 +709,11 @@
   }
 #endif
 
-  uint32_t ctr = CRYPTO_bswap4(ctx->Yi.d[3]);
+  uint32_t ctr = CRYPTO_BSWAP4(ctx->Yi.d[3]);
   while (len >= GHASH_CHUNK) {
     (*stream)(in, out, GHASH_CHUNK / 16, key, ctx->Yi.c);
     ctr += GHASH_CHUNK / 16;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     GHASH(ctx, out, GHASH_CHUNK);
     out += GHASH_CHUNK;
     in += GHASH_CHUNK;
@@ -725,7 +725,7 @@
 
     (*stream)(in, out, j, key, ctx->Yi.c);
     ctr += (unsigned int)j;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     in += len_blocks;
     len -= len_blocks;
     GHASH(ctx, out, len_blocks);
@@ -734,7 +734,7 @@
   if (len) {
     (*ctx->gcm_key.block)(ctx->Yi.c, ctx->EKi.c, key);
     ++ctr;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     while (len--) {
       ctx->Xi.c[n] ^= out[n] = in[n] ^ ctx->EKi.c[n];
       ++n;
@@ -796,12 +796,12 @@
   }
 #endif
 
-  uint32_t ctr = CRYPTO_bswap4(ctx->Yi.d[3]);
+  uint32_t ctr = CRYPTO_BSWAP4(ctx->Yi.d[3]);
   while (len >= GHASH_CHUNK) {
     GHASH(ctx, in, GHASH_CHUNK);
     (*stream)(in, out, GHASH_CHUNK / 16, key, ctx->Yi.c);
     ctr += GHASH_CHUNK / 16;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     out += GHASH_CHUNK;
     in += GHASH_CHUNK;
     len -= GHASH_CHUNK;
@@ -813,7 +813,7 @@
     GHASH(ctx, in, len_blocks);
     (*stream)(in, out, j, key, ctx->Yi.c);
     ctr += (unsigned int)j;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     out += len_blocks;
     in += len_blocks;
     len -= len_blocks;
@@ -821,7 +821,7 @@
   if (len) {
     (*ctx->gcm_key.block)(ctx->Yi.c, ctx->EKi.c, key);
     ++ctr;
-    ctx->Yi.d[3] = CRYPTO_bswap4(ctr);
+    ctx->Yi.d[3] = CRYPTO_BSWAP4(ctr);
     while (len--) {
       uint8_t c = in[n];
       ctx->Xi.c[n] ^= c;
@@ -844,8 +844,8 @@
     GCM_MUL(ctx, Xi);
   }
 
-  ctx->Xi.u[0] ^= CRYPTO_bswap8(ctx->len.u[0] << 3);
-  ctx->Xi.u[1] ^= CRYPTO_bswap8(ctx->len.u[1] << 3);
+  ctx->Xi.u[0] ^= CRYPTO_BSWAP8(ctx->len.u[0] << 3);
+  ctx->Xi.u[1] ^= CRYPTO_BSWAP8(ctx->len.u[1] << 3);
   GCM_MUL(ctx, Xi);
 
   ctx->Xi.u[0] ^= ctx->EK0.u[0];
