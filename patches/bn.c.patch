--- /home/test/bn.c_old	2019-07-19 13:55:06.214890644 +0000
+++ src/crypto/fipsmodule/bn/bn.c	2019-07-19 14:03:27.083407896 +0000
@@ -169,7 +169,7 @@
 }
 
 DEFINE_METHOD_FUNCTION(BIGNUM, BN_value_one) {
-  static const BN_ULONG kOneLimbs[1] = { 1 };
+  static const BN_ULONG kOneLimbs[1] = { BSWAP_64_BITOP(1) }; 
   out->d = (BN_ULONG*) kOneLimbs;
   out->width = 1;
   out->dmax = 1;
@@ -238,7 +238,8 @@
     return 0;
   }
 
-  return (width - 1) * BN_BITS2 + BN_num_bits_word(bn->d[width - 1]);
+  return 
+    (width - 1) * BN_BITS2 + BN_num_bits_word(BSWAP_ULONG(bn->d[width - 1]));
 }
 
 unsigned BN_num_bytes(const BIGNUM *bn) {
@@ -264,7 +265,7 @@
   }
 
   bn->neg = 0;
-  bn->d[0] = value;
+  bn->d[0] = bn->d[0] = BSWAP_ULONG(value);
   bn->width = 1;
   return 1;
 }
@@ -282,8 +283,8 @@
   }
 
   bn->neg = 0;
-  bn->d[0] = (BN_ULONG)value;
-  bn->d[1] = (BN_ULONG)(value >> 32);
+  bn->d[0] = BSWAP_ULONG((BN_ULONG)value); 
+  bn->d[1] = BSWAP_ULONG((BN_ULONG)(value >> 32));
   bn->width = 2;
   return 1;
 #else
@@ -306,7 +307,7 @@
   // All words beyond |num| must be zero.
   BN_ULONG mask = 0;
   for (size_t i = num; i < (size_t)bn->width; i++) {
-    mask |= bn->d[i];
+    mask |= BSWAP_ULONG(bn->d[i]);
   }
   return mask == 0;
 }
@@ -408,13 +409,15 @@
   for (size_t i = 0; i < num; i++) {
     OPENSSL_STATIC_ASSERT(sizeof(BN_ULONG) <= sizeof(crypto_word_t),
                           "crypto_word_t is too small");
-    r[i] = constant_time_select_w(mask, a[i], b[i]);
+    r[i] = BSWAP_ULONG(constant_time_select_w(mask,
+					      BSWAP_ULONG(a[i]),
+					      BSWAP_ULONG(b[i])));
   }
 }
 
 int bn_minimal_width(const BIGNUM *bn) {
   int ret = bn->width;
-  while (ret > 0 && bn->d[ret - 1] == 0) {
+  while (ret > 0 && BSWAP_ULONG(bn->d[ret - 1]) == 0) {
     ret--;
   }
   return ret;
