--- /home/test/gcd_extra.c_old	2019-07-26 07:19:05.406130725 +0000
+++ src/crypto/fipsmodule/bn/gcd_extra.c	2019-07-26 07:26:06.378545308 +0000
@@ -35,7 +35,7 @@
   maybe_rshift1_words(a, mask, tmp, num);
   if (num != 0) {
     carry &= mask;
-    a[num - 1] |= carry << (BN_BITS2-1);
+    a[num - 1] = BSWAP_ULONG(BSWAP_ULONG(a[num - 1]) | (carry << (BN_BITS2-1)));
   }
 }
 
@@ -81,7 +81,7 @@
 
   unsigned shift = 0;
   for (unsigned i = 0; i < num_iters; i++) {
-    BN_ULONG both_odd = word_is_odd_mask(u->d[0]) & word_is_odd_mask(v->d[0]);
+    BN_ULONG both_odd = word_is_odd_mask(BSWAP_ULONG(u->d[0])) & word_is_odd_mask(BSWAP_ULONG(v->d[0]));
 
     // If both |u| and |v| are odd, subtract the smaller from the larger.
     BN_ULONG u_less_than_v =
@@ -91,8 +91,8 @@
     bn_select_words(v->d, both_odd & u_less_than_v, tmp->d, v->d, width);
 
     // At least one of |u| and |v| is now even.
-    BN_ULONG u_is_odd = word_is_odd_mask(u->d[0]);
-    BN_ULONG v_is_odd = word_is_odd_mask(v->d[0]);
+    BN_ULONG u_is_odd = word_is_odd_mask(BSWAP_ULONG(u->d[0]));
+    BN_ULONG v_is_odd = word_is_odd_mask(BSWAP_ULONG(v->d[0]));
     assert(!(u_is_odd & v_is_odd));
 
     // If both are even, the final GCD gains a factor of two.
@@ -140,9 +140,9 @@
   if (gcd->width == 0) {
     *out_relatively_prime = 0;
   } else {
-    BN_ULONG mask = shift | (gcd->d[0] ^ 1);
+    BN_ULONG mask = shift | (BSWAP_ULONG(gcd->d[0]) ^ 1);
     for (int i = 1; i < gcd->width; i++) {
-      mask |= gcd->d[i];
+      mask |= BSWAP_ULONG(gcd->d[i]);
     }
     *out_relatively_prime = mask == 0;
   }
@@ -260,7 +260,7 @@
   // After each loop iteration, u and v only get smaller, and at least one of
   // them shrinks by at least a factor of two.
   for (unsigned i = 0; i < num_iters; i++) {
-    BN_ULONG both_odd = word_is_odd_mask(u->d[0]) & word_is_odd_mask(v->d[0]);
+    BN_ULONG both_odd = word_is_odd_mask(BSWAP_ULONG(u->d[0])) & word_is_odd_mask(BSWAP_ULONG(v->d[0]));
 
     // If both |u| and |v| are odd, subtract the smaller from the larger.
     BN_ULONG v_less_than_u =
@@ -284,14 +284,14 @@
 
     // Our loop invariants hold at this point. Additionally, exactly one of |u|
     // and |v| is now even.
-    BN_ULONG u_is_even = ~word_is_odd_mask(u->d[0]);
-    BN_ULONG v_is_even = ~word_is_odd_mask(v->d[0]);
+    BN_ULONG u_is_even = ~word_is_odd_mask(BSWAP_ULONG(u->d[0]));
+    BN_ULONG v_is_even = ~word_is_odd_mask(BSWAP_ULONG(v->d[0]));
     assert(u_is_even != v_is_even);
 
     // Halve the even one and adjust the corresponding coefficient.
     maybe_rshift1_words(u->d, u_is_even, tmp->d, n_width);
     BN_ULONG A_or_B_is_odd =
-        word_is_odd_mask(A->d[0]) | word_is_odd_mask(B->d[0]);
+        word_is_odd_mask(BSWAP_ULONG(A->d[0])) | word_is_odd_mask(BSWAP_ULONG(B->d[0]));
     BN_ULONG A_carry =
         maybe_add_words(A->d, A_or_B_is_odd & u_is_even, n->d, tmp->d, n_width);
     BN_ULONG B_carry =
@@ -301,7 +301,7 @@
 
     maybe_rshift1_words(v->d, v_is_even, tmp->d, n_width);
     BN_ULONG C_or_D_is_odd =
-        word_is_odd_mask(C->d[0]) | word_is_odd_mask(D->d[0]);
+        word_is_odd_mask(BSWAP_ULONG(C->d[0])) | word_is_odd_mask(BSWAP_ULONG(D->d[0]));
     BN_ULONG C_carry =
         maybe_add_words(C->d, C_or_D_is_odd & v_is_even, n->d, tmp->d, n_width);
     BN_ULONG D_carry =
